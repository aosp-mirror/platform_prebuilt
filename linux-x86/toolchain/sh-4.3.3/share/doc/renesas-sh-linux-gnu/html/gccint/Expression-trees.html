<html lang="en">
<head>
<title>Expression trees - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Trees.html#Trees" title="Trees">
<link rel="prev" href="Attributes.html#Attributes" title="Attributes">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
2007 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="../cs.css">
</head>
<body>
<div class="node">
<a name="Expression-trees"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Attributes.html#Attributes">Attributes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Trees.html#Trees">Trees</a>
<hr>
</div>

<h3 class="section">9.8 Expressions</h3>

<p><a name="index-expression-1937"></a><a name="index-TREE_005fTYPE-1938"></a><a name="index-TREE_005fOPERAND-1939"></a><a name="index-INTEGER_005fCST-1940"></a><a name="index-TREE_005fINT_005fCST_005fHIGH-1941"></a><a name="index-TREE_005fINT_005fCST_005fLOW-1942"></a><a name="index-tree_005fint_005fcst_005flt-1943"></a><a name="index-tree_005fint_005fcst_005fequal-1944"></a><a name="index-REAL_005fCST-1945"></a><a name="index-FIXED_005fCST-1946"></a><a name="index-COMPLEX_005fCST-1947"></a><a name="index-VECTOR_005fCST-1948"></a><a name="index-STRING_005fCST-1949"></a><a name="index-TREE_005fSTRING_005fLENGTH-1950"></a><a name="index-TREE_005fSTRING_005fPOINTER-1951"></a><a name="index-PTRMEM_005fCST-1952"></a><a name="index-PTRMEM_005fCST_005fCLASS-1953"></a><a name="index-PTRMEM_005fCST_005fMEMBER-1954"></a><a name="index-VAR_005fDECL-1955"></a><a name="index-NEGATE_005fEXPR-1956"></a><a name="index-ABS_005fEXPR-1957"></a><a name="index-BIT_005fNOT_005fEXPR-1958"></a><a name="index-TRUTH_005fNOT_005fEXPR-1959"></a><a name="index-PREDECREMENT_005fEXPR-1960"></a><a name="index-PREINCREMENT_005fEXPR-1961"></a><a name="index-POSTDECREMENT_005fEXPR-1962"></a><a name="index-POSTINCREMENT_005fEXPR-1963"></a><a name="index-ADDR_005fEXPR-1964"></a><a name="index-INDIRECT_005fREF-1965"></a><a name="index-FIX_005fTRUNC_005fEXPR-1966"></a><a name="index-FLOAT_005fEXPR-1967"></a><a name="index-COMPLEX_005fEXPR-1968"></a><a name="index-CONJ_005fEXPR-1969"></a><a name="index-REALPART_005fEXPR-1970"></a><a name="index-IMAGPART_005fEXPR-1971"></a><a name="index-NON_005fLVALUE_005fEXPR-1972"></a><a name="index-NOP_005fEXPR-1973"></a><a name="index-CONVERT_005fEXPR-1974"></a><a name="index-FIXED_005fCONVERT_005fEXPR-1975"></a><a name="index-THROW_005fEXPR-1976"></a><a name="index-LSHIFT_005fEXPR-1977"></a><a name="index-RSHIFT_005fEXPR-1978"></a><a name="index-BIT_005fIOR_005fEXPR-1979"></a><a name="index-BIT_005fXOR_005fEXPR-1980"></a><a name="index-BIT_005fAND_005fEXPR-1981"></a><a name="index-TRUTH_005fANDIF_005fEXPR-1982"></a><a name="index-TRUTH_005fORIF_005fEXPR-1983"></a><a name="index-TRUTH_005fAND_005fEXPR-1984"></a><a name="index-TRUTH_005fOR_005fEXPR-1985"></a><a name="index-TRUTH_005fXOR_005fEXPR-1986"></a><a name="index-POINTER_005fPLUS_005fEXPR-1987"></a><a name="index-PLUS_005fEXPR-1988"></a><a name="index-MINUS_005fEXPR-1989"></a><a name="index-MULT_005fEXPR-1990"></a><a name="index-RDIV_005fEXPR-1991"></a><a name="index-TRUNC_005fDIV_005fEXPR-1992"></a><a name="index-FLOOR_005fDIV_005fEXPR-1993"></a><a name="index-CEIL_005fDIV_005fEXPR-1994"></a><a name="index-ROUND_005fDIV_005fEXPR-1995"></a><a name="index-TRUNC_005fMOD_005fEXPR-1996"></a><a name="index-FLOOR_005fMOD_005fEXPR-1997"></a><a name="index-CEIL_005fMOD_005fEXPR-1998"></a><a name="index-ROUND_005fMOD_005fEXPR-1999"></a><a name="index-EXACT_005fDIV_005fEXPR-2000"></a><a name="index-ARRAY_005fREF-2001"></a><a name="index-ARRAY_005fRANGE_005fREF-2002"></a><a name="index-TARGET_005fMEM_005fREF-2003"></a><a name="index-LT_005fEXPR-2004"></a><a name="index-LE_005fEXPR-2005"></a><a name="index-GT_005fEXPR-2006"></a><a name="index-GE_005fEXPR-2007"></a><a name="index-EQ_005fEXPR-2008"></a><a name="index-NE_005fEXPR-2009"></a><a name="index-ORDERED_005fEXPR-2010"></a><a name="index-UNORDERED_005fEXPR-2011"></a><a name="index-UNLT_005fEXPR-2012"></a><a name="index-UNLE_005fEXPR-2013"></a><a name="index-UNGT_005fEXPR-2014"></a><a name="index-UNGE_005fEXPR-2015"></a><a name="index-UNEQ_005fEXPR-2016"></a><a name="index-LTGT_005fEXPR-2017"></a><a name="index-MODIFY_005fEXPR-2018"></a><a name="index-INIT_005fEXPR-2019"></a><a name="index-COMPONENT_005fREF-2020"></a><a name="index-COMPOUND_005fEXPR-2021"></a><a name="index-COND_005fEXPR-2022"></a><a name="index-CALL_005fEXPR-2023"></a><a name="index-STMT_005fEXPR-2024"></a><a name="index-BIND_005fEXPR-2025"></a><a name="index-LOOP_005fEXPR-2026"></a><a name="index-EXIT_005fEXPR-2027"></a><a name="index-CLEANUP_005fPOINT_005fEXPR-2028"></a><a name="index-CONSTRUCTOR-2029"></a><a name="index-COMPOUND_005fLITERAL_005fEXPR-2030"></a><a name="index-SAVE_005fEXPR-2031"></a><a name="index-TARGET_005fEXPR-2032"></a><a name="index-AGGR_005fINIT_005fEXPR-2033"></a><a name="index-VA_005fARG_005fEXPR-2034"></a><a name="index-CHANGE_005fDYNAMIC_005fTYPE_005fEXPR-2035"></a><a name="index-OMP_005fPARALLEL-2036"></a><a name="index-OMP_005fFOR-2037"></a><a name="index-OMP_005fSECTIONS-2038"></a><a name="index-OMP_005fSINGLE-2039"></a><a name="index-OMP_005fSECTION-2040"></a><a name="index-OMP_005fMASTER-2041"></a><a name="index-OMP_005fORDERED-2042"></a><a name="index-OMP_005fCRITICAL-2043"></a><a name="index-OMP_005fRETURN-2044"></a><a name="index-OMP_005fCONTINUE-2045"></a><a name="index-OMP_005fATOMIC-2046"></a><a name="index-OMP_005fCLAUSE-2047"></a><a name="index-VEC_005fLSHIFT_005fEXPR-2048"></a><a name="index-VEC_005fRSHIFT_005fEXPR-2049"></a><a name="index-VEC_005fWIDEN_005fMULT_005fHI_005fEXPR-2050"></a><a name="index-VEC_005fWIDEN_005fMULT_005fLO_005fEXPR-2051"></a><a name="index-VEC_005fUNPACK_005fHI_005fEXPR-2052"></a><a name="index-VEC_005fUNPACK_005fLO_005fEXPR-2053"></a><a name="index-VEC_005fUNPACK_005fFLOAT_005fHI_005fEXPR-2054"></a><a name="index-VEC_005fUNPACK_005fFLOAT_005fLO_005fEXPR-2055"></a><a name="index-VEC_005fPACK_005fTRUNC_005fEXPR-2056"></a><a name="index-VEC_005fPACK_005fSAT_005fEXPR-2057"></a><a name="index-VEC_005fPACK_005fFIX_005fTRUNC_005fEXPR-2058"></a><a name="index-VEC_005fEXTRACT_005fEVEN_005fEXPR-2059"></a><a name="index-VEC_005fEXTRACT_005fODD_005fEXPR-2060"></a><a name="index-VEC_005fINTERLEAVE_005fHIGH_005fEXPR-2061"></a><a name="index-VEC_005fINTERLEAVE_005fLOW_005fEXPR-2062"></a>
The internal representation for expressions is for the most part quite
straightforward.  However, there are a few facts that one must bear in
mind.  In particular, the expression &ldquo;tree&rdquo; is actually a directed
acyclic graph.  (For example there may be many references to the integer
constant zero throughout the source program; many of these will be
represented by the same expression node.)  You should not rely on
certain kinds of node being shared, nor should you rely on certain kinds of
nodes being unshared.

 <p>The following macros can be used with all expression nodes:

     <dl>
<dt><code>TREE_TYPE</code><a name="index-TREE_005fTYPE-2063"></a><dd>Returns the type of the expression.  This value may not be precisely the
same type that would be given the expression in the original program. 
</dl>

 <p>In what follows, some nodes that one might expect to always have type
<code>bool</code> are documented to have either integral or boolean type.  At
some point in the future, the C front end may also make use of this same
intermediate representation, and at this point these nodes will
certainly have integral type.  The previous sentence is not meant to
imply that the C++ front end does not or will not give these nodes
integral type.

 <p>Below, we list the various kinds of expression nodes.  Except where
noted otherwise, the operands to an expression are accessed using the
<code>TREE_OPERAND</code> macro.  For example, to access the first operand to
a binary plus expression <code>expr</code>, use:

<pre class="smallexample">     TREE_OPERAND (expr, 0)
</pre>
 <p class="noindent">As this example indicates, the operands are zero-indexed.

 <p>All the expressions starting with <code>OMP_</code> represent directives and
clauses used by the OpenMP API <a href="http://www.openmp.org/">http://www.openmp.org/</a><!-- /@w -->.

 <p>The table below begins with constants, moves on to unary expressions,
then proceeds to binary expressions, and concludes with various other
kinds of expressions:

     <dl>
<dt><code>INTEGER_CST</code><dd>These nodes represent integer constants.  Note that the type of these
constants is obtained with <code>TREE_TYPE</code>; they are not always of type
<code>int</code>.  In particular, <code>char</code> constants are represented with
<code>INTEGER_CST</code> nodes.  The value of the integer constant <code>e</code> is
given by
     <pre class="smallexample">          ((TREE_INT_CST_HIGH (e) &lt;&lt; HOST_BITS_PER_WIDE_INT)
          + TREE_INST_CST_LOW (e))
</pre>
     <p class="noindent">HOST_BITS_PER_WIDE_INT is at least thirty-two on all platforms.  Both
<code>TREE_INT_CST_HIGH</code> and <code>TREE_INT_CST_LOW</code> return a
<code>HOST_WIDE_INT</code>.  The value of an <code>INTEGER_CST</code> is interpreted
as a signed or unsigned quantity depending on the type of the constant. 
In general, the expression given above will overflow, so it should not
be used to calculate the value of the constant.

     <p>The variable <code>integer_zero_node</code> is an integer constant with value
zero.  Similarly, <code>integer_one_node</code> is an integer constant with
value one.  The <code>size_zero_node</code> and <code>size_one_node</code> variables
are analogous, but have type <code>size_t</code> rather than <code>int</code>.

     <p>The function <code>tree_int_cst_lt</code> is a predicate which holds if its
first argument is less than its second.  Both constants are assumed to
have the same signedness (i.e., either both should be signed or both
should be unsigned.)  The full width of the constant is used when doing
the comparison; the usual rules about promotions and conversions are
ignored.  Similarly, <code>tree_int_cst_equal</code> holds if the two
constants are equal.  The <code>tree_int_cst_sgn</code> function returns the
sign of a constant.  The value is <code>1</code>, <code>0</code>, or <code>-1</code>
according on whether the constant is greater than, equal to, or less
than zero.  Again, the signedness of the constant's type is taken into
account; an unsigned constant is never less than zero, no matter what
its bit-pattern.

     <br><dt><code>REAL_CST</code><dd>
FIXME: Talk about how to obtain representations of this constant, do
comparisons, and so forth.

     <br><dt><code>FIXED_CST</code><dd>
These nodes represent fixed-point constants.  The type of these constants
is obtained with <code>TREE_TYPE</code>.  <code>TREE_FIXED_CST_PTR</code> points to
to struct fixed_value;  <code>TREE_FIXED_CST</code> returns the structure itself. 
Struct fixed_value contains <code>data</code> with the size of two
HOST_BITS_PER_WIDE_INT and <code>mode</code> as the associated fixed-point
machine mode for <code>data</code>.

     <br><dt><code>COMPLEX_CST</code><dd>These nodes are used to represent complex number constants, that is a
<code>__complex__</code> whose parts are constant nodes.  The
<code>TREE_REALPART</code> and <code>TREE_IMAGPART</code> return the real and the
imaginary parts respectively.

     <br><dt><code>VECTOR_CST</code><dd>These nodes are used to represent vector constants, whose parts are
constant nodes.  Each individual constant node is either an integer or a
double constant node.  The first operand is a <code>TREE_LIST</code> of the
constant nodes and is accessed through <code>TREE_VECTOR_CST_ELTS</code>.

     <br><dt><code>STRING_CST</code><dd>These nodes represent string-constants.  The <code>TREE_STRING_LENGTH</code>
returns the length of the string, as an <code>int</code>.  The
<code>TREE_STRING_POINTER</code> is a <code>char*</code> containing the string
itself.  The string may not be <code>NUL</code>-terminated, and it may contain
embedded <code>NUL</code> characters.  Therefore, the
<code>TREE_STRING_LENGTH</code> includes the trailing <code>NUL</code> if it is
present.

     <p>For wide string constants, the <code>TREE_STRING_LENGTH</code> is the number
of bytes in the string, and the <code>TREE_STRING_POINTER</code>
points to an array of the bytes of the string, as represented on the
target system (that is, as integers in the target endianness).  Wide and
non-wide string constants are distinguished only by the <code>TREE_TYPE</code>
of the <code>STRING_CST</code>.

     <p>FIXME: The formats of string constants are not well-defined when the
target system bytes are not the same width as host system bytes.

     <br><dt><code>PTRMEM_CST</code><dd>These nodes are used to represent pointer-to-member constants.  The
<code>PTRMEM_CST_CLASS</code> is the class type (either a <code>RECORD_TYPE</code>
or <code>UNION_TYPE</code> within which the pointer points), and the
<code>PTRMEM_CST_MEMBER</code> is the declaration for the pointed to object. 
Note that the <code>DECL_CONTEXT</code> for the <code>PTRMEM_CST_MEMBER</code> is in
general different from the <code>PTRMEM_CST_CLASS</code>.  For example,
given:
     <pre class="smallexample">          struct B { int i; };
          struct D : public B {};
          int D::*dp = &amp;D::i;
</pre>
     <p class="noindent">The <code>PTRMEM_CST_CLASS</code> for <code>&amp;D::i</code> is <code>D</code>, even though
the <code>DECL_CONTEXT</code> for the <code>PTRMEM_CST_MEMBER</code> is <code>B</code>,
since <code>B::i</code> is a member of <code>B</code>, not <code>D</code>.

     <br><dt><code>VAR_DECL</code><dd>
These nodes represent variables, including static data members.  For
more information, see <a href="Declarations.html#Declarations">Declarations</a>.

     <br><dt><code>NEGATE_EXPR</code><dd>These nodes represent unary negation of the single operand, for both
integer and floating-point types.  The type of negation can be
determined by looking at the type of the expression.

     <p>The behavior of this operation on signed arithmetic overflow is
controlled by the <code>flag_wrapv</code> and <code>flag_trapv</code> variables.

     <br><dt><code>ABS_EXPR</code><dd>These nodes represent the absolute value of the single operand, for
both integer and floating-point types.  This is typically used to
implement the <code>abs</code>, <code>labs</code> and <code>llabs</code> builtins for
integer types, and the <code>fabs</code>, <code>fabsf</code> and <code>fabsl</code>
builtins for floating point types.  The type of abs operation can
be determined by looking at the type of the expression.

     <p>This node is not used for complex types.  To represent the modulus
or complex abs of a complex value, use the <code>BUILT_IN_CABS</code>,
<code>BUILT_IN_CABSF</code> or <code>BUILT_IN_CABSL</code> builtins, as used
to implement the C99 <code>cabs</code>, <code>cabsf</code> and <code>cabsl</code>
built-in functions.

     <br><dt><code>BIT_NOT_EXPR</code><dd>These nodes represent bitwise complement, and will always have integral
type.  The only operand is the value to be complemented.

     <br><dt><code>TRUTH_NOT_EXPR</code><dd>These nodes represent logical negation, and will always have integral
(or boolean) type.  The operand is the value being negated.  The type
of the operand and that of the result are always of <code>BOOLEAN_TYPE</code>
or <code>INTEGER_TYPE</code>.

     <br><dt><code>PREDECREMENT_EXPR</code><dt><code>PREINCREMENT_EXPR</code><dt><code>POSTDECREMENT_EXPR</code><dt><code>POSTINCREMENT_EXPR</code><dd>These nodes represent increment and decrement expressions.  The value of
the single operand is computed, and the operand incremented or
decremented.  In the case of <code>PREDECREMENT_EXPR</code> and
<code>PREINCREMENT_EXPR</code>, the value of the expression is the value
resulting after the increment or decrement; in the case of
<code>POSTDECREMENT_EXPR</code> and <code>POSTINCREMENT_EXPR</code> is the value
before the increment or decrement occurs.  The type of the operand, like
that of the result, will be either integral, boolean, or floating-point.

     <br><dt><code>ADDR_EXPR</code><dd>These nodes are used to represent the address of an object.  (These
expressions will always have pointer or reference type.)  The operand may
be another expression, or it may be a declaration.

     <p>As an extension, GCC allows users to take the address of a label.  In
this case, the operand of the <code>ADDR_EXPR</code> will be a
<code>LABEL_DECL</code>.  The type of such an expression is <code>void*</code>.

     <p>If the object addressed is not an lvalue, a temporary is created, and
the address of the temporary is used.

     <br><dt><code>INDIRECT_REF</code><dd>These nodes are used to represent the object pointed to by a pointer. 
The operand is the pointer being dereferenced; it will always have
pointer or reference type.

     <br><dt><code>FIX_TRUNC_EXPR</code><dd>These nodes represent conversion of a floating-point value to an
integer.  The single operand will have a floating-point type, while
the complete expression will have an integral (or boolean) type.  The
operand is rounded towards zero.

     <br><dt><code>FLOAT_EXPR</code><dd>These nodes represent conversion of an integral (or boolean) value to a
floating-point value.  The single operand will have integral type, while
the complete expression will have a floating-point type.

     <p>FIXME: How is the operand supposed to be rounded?  Is this dependent on
<samp><span class="option">-mieee</span></samp>?

     <br><dt><code>COMPLEX_EXPR</code><dd>These nodes are used to represent complex numbers constructed from two
expressions of the same (integer or real) type.  The first operand is the
real part and the second operand is the imaginary part.

     <br><dt><code>CONJ_EXPR</code><dd>These nodes represent the conjugate of their operand.

     <br><dt><code>REALPART_EXPR</code><dt><code>IMAGPART_EXPR</code><dd>These nodes represent respectively the real and the imaginary parts
of complex numbers (their sole argument).

     <br><dt><code>NON_LVALUE_EXPR</code><dd>These nodes indicate that their one and only operand is not an lvalue. 
A back end can treat these identically to the single operand.

     <br><dt><code>NOP_EXPR</code><dd>These nodes are used to represent conversions that do not require any
code-generation.  For example, conversion of a <code>char*</code> to an
<code>int*</code> does not require any code be generated; such a conversion is
represented by a <code>NOP_EXPR</code>.  The single operand is the expression
to be converted.  The conversion from a pointer to a reference is also
represented with a <code>NOP_EXPR</code>.

     <br><dt><code>CONVERT_EXPR</code><dd>These nodes are similar to <code>NOP_EXPR</code>s, but are used in those
situations where code may need to be generated.  For example, if an
<code>int*</code> is converted to an <code>int</code> code may need to be generated
on some platforms.  These nodes are never used for C++-specific
conversions, like conversions between pointers to different classes in
an inheritance hierarchy.  Any adjustments that need to be made in such
cases are always indicated explicitly.  Similarly, a user-defined
conversion is never represented by a <code>CONVERT_EXPR</code>; instead, the
function calls are made explicit.

     <br><dt><code>FIXED_CONVERT_EXPR</code><dd>These nodes are used to represent conversions that involve fixed-point
values.  For example, from a fixed-point value to another fixed-point value,
from an integer to a fixed-point value, from a fixed-point value to an
integer, from a floating-point value to a fixed-point value, or from
a fixed-point value to a floating-point value.

     <br><dt><code>THROW_EXPR</code><dd>These nodes represent <code>throw</code> expressions.  The single operand is
an expression for the code that should be executed to throw the
exception.  However, there is one implicit action not represented in
that expression; namely the call to <code>__throw</code>.  This function takes
no arguments.  If <code>setjmp</code>/<code>longjmp</code> exceptions are used, the
function <code>__sjthrow</code> is called instead.  The normal GCC back end
uses the function <code>emit_throw</code> to generate this code; you can
examine this function to see what needs to be done.

     <br><dt><code>LSHIFT_EXPR</code><dt><code>RSHIFT_EXPR</code><dd>These nodes represent left and right shifts, respectively.  The first
operand is the value to shift; it will always be of integral type.  The
second operand is an expression for the number of bits by which to
shift.  Right shift should be treated as arithmetic, i.e., the
high-order bits should be zero-filled when the expression has unsigned
type and filled with the sign bit when the expression has signed type. 
Note that the result is undefined if the second operand is larger
than or equal to the first operand's type size.

     <br><dt><code>BIT_IOR_EXPR</code><dt><code>BIT_XOR_EXPR</code><dt><code>BIT_AND_EXPR</code><dd>These nodes represent bitwise inclusive or, bitwise exclusive or, and
bitwise and, respectively.  Both operands will always have integral
type.

     <br><dt><code>TRUTH_ANDIF_EXPR</code><dt><code>TRUTH_ORIF_EXPR</code><dd>These nodes represent logical &ldquo;and&rdquo; and logical &ldquo;or&rdquo;, respectively. 
These operators are not strict; i.e., the second operand is evaluated
only if the value of the expression is not determined by evaluation of
the first operand.  The type of the operands and that of the result are
always of <code>BOOLEAN_TYPE</code> or <code>INTEGER_TYPE</code>.

     <br><dt><code>TRUTH_AND_EXPR</code><dt><code>TRUTH_OR_EXPR</code><dt><code>TRUTH_XOR_EXPR</code><dd>These nodes represent logical and, logical or, and logical exclusive or. 
They are strict; both arguments are always evaluated.  There are no
corresponding operators in C or C++, but the front end will sometimes
generate these expressions anyhow, if it can tell that strictness does
not matter.  The type of the operands and that of the result are
always of <code>BOOLEAN_TYPE</code> or <code>INTEGER_TYPE</code>.

     <dt><code>POINTER_PLUS_EXPR</code><dd>This node represents pointer arithmetic.  The first operand is always
a pointer/reference type.  The second operand is always an unsigned
integer type compatible with sizetype.  This is the only binary
arithmetic operand that can operate on pointer types.

     <dt><code>PLUS_EXPR</code><dt><code>MINUS_EXPR</code><dt><code>MULT_EXPR</code><dd>These nodes represent various binary arithmetic operations. 
Respectively, these operations are addition, subtraction (of the second
operand from the first) and multiplication.  Their operands may have
either integral or floating type, but there will never be case in which
one operand is of floating type and the other is of integral type.

     <p>The behavior of these operations on signed arithmetic overflow is
controlled by the <code>flag_wrapv</code> and <code>flag_trapv</code> variables.

     <br><dt><code>RDIV_EXPR</code><dd>This node represents a floating point division operation.

     <br><dt><code>TRUNC_DIV_EXPR</code><dt><code>FLOOR_DIV_EXPR</code><dt><code>CEIL_DIV_EXPR</code><dt><code>ROUND_DIV_EXPR</code><dd>These nodes represent integer division operations that return an integer
result.  <code>TRUNC_DIV_EXPR</code> rounds towards zero, <code>FLOOR_DIV_EXPR</code>
rounds towards negative infinity, <code>CEIL_DIV_EXPR</code> rounds towards
positive infinity and <code>ROUND_DIV_EXPR</code> rounds to the closest integer. 
Integer division in C and C++ is truncating, i.e. <code>TRUNC_DIV_EXPR</code>.

     <p>The behavior of these operations on signed arithmetic overflow, when
dividing the minimum signed integer by minus one, is controlled by the
<code>flag_wrapv</code> and <code>flag_trapv</code> variables.

     <br><dt><code>TRUNC_MOD_EXPR</code><dt><code>FLOOR_MOD_EXPR</code><dt><code>CEIL_MOD_EXPR</code><dt><code>ROUND_MOD_EXPR</code><dd>These nodes represent the integer remainder or modulus operation. 
The integer modulus of two operands <code>a</code> and <code>b</code> is
defined as <code>a - (a/b)*b</code> where the division calculated using
the corresponding division operator.  Hence for <code>TRUNC_MOD_EXPR</code>
this definition assumes division using truncation towards zero, i.e. 
<code>TRUNC_DIV_EXPR</code>.  Integer remainder in C and C++ uses truncating
division, i.e. <code>TRUNC_MOD_EXPR</code>.

     <br><dt><code>EXACT_DIV_EXPR</code><dd>The <code>EXACT_DIV_EXPR</code> code is used to represent integer divisions where
the numerator is known to be an exact multiple of the denominator.  This
allows the backend to choose between the faster of <code>TRUNC_DIV_EXPR</code>,
<code>CEIL_DIV_EXPR</code> and <code>FLOOR_DIV_EXPR</code> for the current target.

     <br><dt><code>ARRAY_REF</code><dd>These nodes represent array accesses.  The first operand is the array;
the second is the index.  To calculate the address of the memory
accessed, you must scale the index by the size of the type of the array
elements.  The type of these expressions must be the type of a component of
the array.  The third and fourth operands are used after gimplification
to represent the lower bound and component size but should not be used
directly; call <code>array_ref_low_bound</code> and <code>array_ref_element_size</code>
instead.

     <br><dt><code>ARRAY_RANGE_REF</code><dd>These nodes represent access to a range (or &ldquo;slice&rdquo;) of an array.  The
operands are the same as that for <code>ARRAY_REF</code> and have the same
meanings.  The type of these expressions must be an array whose component
type is the same as that of the first operand.  The range of that array
type determines the amount of data these expressions access.

     <br><dt><code>TARGET_MEM_REF</code><dd>These nodes represent memory accesses whose address directly map to
an addressing mode of the target architecture.  The first argument
is <code>TMR_SYMBOL</code> and must be a <code>VAR_DECL</code> of an object with
a fixed address.  The second argument is <code>TMR_BASE</code> and the
third one is <code>TMR_INDEX</code>.  The fourth argument is
<code>TMR_STEP</code> and must be an <code>INTEGER_CST</code>.  The fifth
argument is <code>TMR_OFFSET</code> and must be an <code>INTEGER_CST</code>. 
Any of the arguments may be NULL if the appropriate component
does not appear in the address.  Address of the <code>TARGET_MEM_REF</code>
is determined in the following way.

     <pre class="smallexample">          &amp;TMR_SYMBOL + TMR_BASE + TMR_INDEX * TMR_STEP + TMR_OFFSET
</pre>
     <p>The sixth argument is the reference to the original memory access, which
is preserved for the purposes of the RTL alias analysis.  The seventh
argument is a tag representing the results of tree level alias analysis.

     <br><dt><code>LT_EXPR</code><dt><code>LE_EXPR</code><dt><code>GT_EXPR</code><dt><code>GE_EXPR</code><dt><code>EQ_EXPR</code><dt><code>NE_EXPR</code><dd>These nodes represent the less than, less than or equal to, greater
than, greater than or equal to, equal, and not equal comparison
operators.  The first and second operand with either be both of integral
type or both of floating type.  The result type of these expressions
will always be of integral or boolean type.  These operations return
the result type's zero value for false, and the result type's one value
for true.

     <p>For floating point comparisons, if we honor IEEE NaNs and either operand
is NaN, then <code>NE_EXPR</code> always returns true and the remaining operators
always return false.  On some targets, comparisons against an IEEE NaN,
other than equality and inequality, may generate a floating point exception.

     <br><dt><code>ORDERED_EXPR</code><dt><code>UNORDERED_EXPR</code><dd>These nodes represent non-trapping ordered and unordered comparison
operators.  These operations take two floating point operands and
determine whether they are ordered or unordered relative to each other. 
If either operand is an IEEE NaN, their comparison is defined to be
unordered, otherwise the comparison is defined to be ordered.  The
result type of these expressions will always be of integral or boolean
type.  These operations return the result type's zero value for false,
and the result type's one value for true.

     <br><dt><code>UNLT_EXPR</code><dt><code>UNLE_EXPR</code><dt><code>UNGT_EXPR</code><dt><code>UNGE_EXPR</code><dt><code>UNEQ_EXPR</code><dt><code>LTGT_EXPR</code><dd>These nodes represent the unordered comparison operators. 
These operations take two floating point operands and determine whether
the operands are unordered or are less than, less than or equal to,
greater than, greater than or equal to, or equal respectively.  For
example, <code>UNLT_EXPR</code> returns true if either operand is an IEEE
NaN or the first operand is less than the second.  With the possible
exception of <code>LTGT_EXPR</code>, all of these operations are guaranteed
not to generate a floating point exception.  The result
type of these expressions will always be of integral or boolean type. 
These operations return the result type's zero value for false,
and the result type's one value for true.

     <br><dt><code>MODIFY_EXPR</code><dd>These nodes represent assignment.  The left-hand side is the first
operand; the right-hand side is the second operand.  The left-hand side
will be a <code>VAR_DECL</code>, <code>INDIRECT_REF</code>, <code>COMPONENT_REF</code>, or
other lvalue.

     <p>These nodes are used to represent not only assignment with &lsquo;<samp><span class="samp">=</span></samp>&rsquo; but
also compound assignments (like &lsquo;<samp><span class="samp">+=</span></samp>&rsquo;), by reduction to &lsquo;<samp><span class="samp">=</span></samp>&rsquo;
assignment.  In other words, the representation for &lsquo;<samp><span class="samp">i += 3</span></samp>&rsquo; looks
just like that for &lsquo;<samp><span class="samp">i = i + 3</span></samp>&rsquo;.

     <br><dt><code>INIT_EXPR</code><dd>These nodes are just like <code>MODIFY_EXPR</code>, but are used only when a
variable is initialized, rather than assigned to subsequently.  This
means that we can assume that the target of the initialization is not
used in computing its own value; any reference to the lhs in computing
the rhs is undefined.

     <br><dt><code>COMPONENT_REF</code><dd>These nodes represent non-static data member accesses.  The first
operand is the object (rather than a pointer to it); the second operand
is the <code>FIELD_DECL</code> for the data member.  The third operand represents
the byte offset of the field, but should not be used directly; call
<code>component_ref_field_offset</code> instead.

     <br><dt><code>COMPOUND_EXPR</code><dd>These nodes represent comma-expressions.  The first operand is an
expression whose value is computed and thrown away prior to the
evaluation of the second operand.  The value of the entire expression is
the value of the second operand.

     <br><dt><code>COND_EXPR</code><dd>These nodes represent <code>?:</code> expressions.  The first operand
is of boolean or integral type.  If it evaluates to a nonzero value,
the second operand should be evaluated, and returned as the value of the
expression.  Otherwise, the third operand is evaluated, and returned as
the value of the expression.

     <p>The second operand must have the same type as the entire expression,
unless it unconditionally throws an exception or calls a noreturn
function, in which case it should have void type.  The same constraints
apply to the third operand.  This allows array bounds checks to be
represented conveniently as <code>(i &gt;= 0 &amp;&amp; i &lt; 10) ? i : abort()</code>.

     <p>As a GNU extension, the C language front-ends allow the second
operand of the <code>?:</code> operator may be omitted in the source. 
For example, <code>x ? : 3</code> is equivalent to <code>x ? x : 3</code>,
assuming that <code>x</code> is an expression without side-effects. 
In the tree representation, however, the second operand is always
present, possibly protected by <code>SAVE_EXPR</code> if the first
argument does cause side-effects.

     <br><dt><code>CALL_EXPR</code><dd>These nodes are used to represent calls to functions, including
non-static member functions.  <code>CALL_EXPR</code>s are implemented as
expression nodes with a variable number of operands.  Rather than using
<code>TREE_OPERAND</code> to extract them, it is preferable to use the
specialized accessor macros and functions that operate specifically on
<code>CALL_EXPR</code> nodes.

     <p><code>CALL_EXPR_FN</code> returns a pointer to the
function to call; it is always an expression whose type is a
<code>POINTER_TYPE</code>.

     <p>The number of arguments to the call is returned by <code>call_expr_nargs</code>,
while the arguments themselves can be accessed with the <code>CALL_EXPR_ARG</code>
macro.  The arguments are zero-indexed and numbered left-to-right. 
You can iterate over the arguments using <code>FOR_EACH_CALL_EXPR_ARG</code>, as in:

     <pre class="smallexample">          tree call, arg;
          call_expr_arg_iterator iter;
          FOR_EACH_CALL_EXPR_ARG (arg, iter, call)
            /* arg is bound to successive arguments of call.  */
            ...;
</pre>
     <p>For non-static
member functions, there will be an operand corresponding to the
<code>this</code> pointer.  There will always be expressions corresponding to
all of the arguments, even if the function is declared with default
arguments and some arguments are not explicitly provided at the call
sites.

     <p><code>CALL_EXPR</code>s also have a <code>CALL_EXPR_STATIC_CHAIN</code> operand that
is used to implement nested functions.  This operand is otherwise null.

     <br><dt><code>STMT_EXPR</code><dd>These nodes are used to represent GCC's statement-expression extension. 
The statement-expression extension allows code like this:
     <pre class="smallexample">          int f() { return ({ int j; j = 3; j + 7; }); }
</pre>
     <p>In other words, an sequence of statements may occur where a single
expression would normally appear.  The <code>STMT_EXPR</code> node represents
such an expression.  The <code>STMT_EXPR_STMT</code> gives the statement
contained in the expression.  The value of the expression is the value
of the last sub-statement in the body.  More precisely, the value is the
value computed by the last statement nested inside <code>BIND_EXPR</code>,
<code>TRY_FINALLY_EXPR</code>, or <code>TRY_CATCH_EXPR</code>.  For example, in:
     <pre class="smallexample">          ({ 3; })
</pre>
     <p>the value is <code>3</code> while in:
     <pre class="smallexample">          ({ if (x) { 3; } })
</pre>
     <p>there is no value.  If the <code>STMT_EXPR</code> does not yield a value,
it's type will be <code>void</code>.

     <br><dt><code>BIND_EXPR</code><dd>These nodes represent local blocks.  The first operand is a list of
variables, connected via their <code>TREE_CHAIN</code> field.  These will
never require cleanups.  The scope of these variables is just the body
of the <code>BIND_EXPR</code>.  The body of the <code>BIND_EXPR</code> is the
second operand.

     <br><dt><code>LOOP_EXPR</code><dd>These nodes represent &ldquo;infinite&rdquo; loops.  The <code>LOOP_EXPR_BODY</code>
represents the body of the loop.  It should be executed forever, unless
an <code>EXIT_EXPR</code> is encountered.

     <br><dt><code>EXIT_EXPR</code><dd>These nodes represent conditional exits from the nearest enclosing
<code>LOOP_EXPR</code>.  The single operand is the condition; if it is
nonzero, then the loop should be exited.  An <code>EXIT_EXPR</code> will only
appear within a <code>LOOP_EXPR</code>.

     <br><dt><code>CLEANUP_POINT_EXPR</code><dd>These nodes represent full-expressions.  The single operand is an
expression to evaluate.  Any destructor calls engendered by the creation
of temporaries during the evaluation of that expression should be
performed immediately after the expression is evaluated.

     <br><dt><code>CONSTRUCTOR</code><dd>These nodes represent the brace-enclosed initializers for a structure or
array.  The first operand is reserved for use by the back end.  The
second operand is a <code>TREE_LIST</code>.  If the <code>TREE_TYPE</code> of the
<code>CONSTRUCTOR</code> is a <code>RECORD_TYPE</code> or <code>UNION_TYPE</code>, then
the <code>TREE_PURPOSE</code> of each node in the <code>TREE_LIST</code> will be a
<code>FIELD_DECL</code> and the <code>TREE_VALUE</code> of each node will be the
expression used to initialize that field.

     <p>If the <code>TREE_TYPE</code> of the <code>CONSTRUCTOR</code> is an
<code>ARRAY_TYPE</code>, then the <code>TREE_PURPOSE</code> of each element in the
<code>TREE_LIST</code> will be an <code>INTEGER_CST</code> or a <code>RANGE_EXPR</code> of
two <code>INTEGER_CST</code>s.  A single <code>INTEGER_CST</code> indicates which
element of the array (indexed from zero) is being assigned to.  A
<code>RANGE_EXPR</code> indicates an inclusive range of elements to
initialize.  In both cases the <code>TREE_VALUE</code> is the corresponding
initializer.  It is re-evaluated for each element of a
<code>RANGE_EXPR</code>.  If the <code>TREE_PURPOSE</code> is <code>NULL_TREE</code>, then
the initializer is for the next available array element.

     <p>In the front end, you should not depend on the fields appearing in any
particular order.  However, in the middle end, fields must appear in
declaration order.  You should not assume that all fields will be
represented.  Unrepresented fields will be set to zero.

     <br><dt><code>COMPOUND_LITERAL_EXPR</code><dd><a name="index-COMPOUND_005fLITERAL_005fEXPR_005fDECL_005fSTMT-2064"></a><a name="index-COMPOUND_005fLITERAL_005fEXPR_005fDECL-2065"></a>These nodes represent ISO C99 compound literals.  The
<code>COMPOUND_LITERAL_EXPR_DECL_STMT</code> is a <code>DECL_STMT</code>
containing an anonymous <code>VAR_DECL</code> for
the unnamed object represented by the compound literal; the
<code>DECL_INITIAL</code> of that <code>VAR_DECL</code> is a <code>CONSTRUCTOR</code>
representing the brace-enclosed list of initializers in the compound
literal.  That anonymous <code>VAR_DECL</code> can also be accessed directly
by the <code>COMPOUND_LITERAL_EXPR_DECL</code> macro.

     <br><dt><code>SAVE_EXPR</code><dd>
A <code>SAVE_EXPR</code> represents an expression (possibly involving
side-effects) that is used more than once.  The side-effects should
occur only the first time the expression is evaluated.  Subsequent uses
should just reuse the computed value.  The first operand to the
<code>SAVE_EXPR</code> is the expression to evaluate.  The side-effects should
be executed where the <code>SAVE_EXPR</code> is first encountered in a
depth-first preorder traversal of the expression tree.

     <br><dt><code>TARGET_EXPR</code><dd>A <code>TARGET_EXPR</code> represents a temporary object.  The first operand
is a <code>VAR_DECL</code> for the temporary variable.  The second operand is
the initializer for the temporary.  The initializer is evaluated and,
if non-void, copied (bitwise) into the temporary.  If the initializer
is void, that means that it will perform the initialization itself.

     <p>Often, a <code>TARGET_EXPR</code> occurs on the right-hand side of an
assignment, or as the second operand to a comma-expression which is
itself the right-hand side of an assignment, etc.  In this case, we say
that the <code>TARGET_EXPR</code> is &ldquo;normal&rdquo;; otherwise, we say it is
&ldquo;orphaned&rdquo;.  For a normal <code>TARGET_EXPR</code> the temporary variable
should be treated as an alias for the left-hand side of the assignment,
rather than as a new temporary variable.

     <p>The third operand to the <code>TARGET_EXPR</code>, if present, is a
cleanup-expression (i.e., destructor call) for the temporary.  If this
expression is orphaned, then this expression must be executed when the
statement containing this expression is complete.  These cleanups must
always be executed in the order opposite to that in which they were
encountered.  Note that if a temporary is created on one branch of a
conditional operator (i.e., in the second or third operand to a
<code>COND_EXPR</code>), the cleanup must be run only if that branch is
actually executed.

     <p>See <code>STMT_IS_FULL_EXPR_P</code> for more information about running these
cleanups.

     <br><dt><code>AGGR_INIT_EXPR</code><dd>An <code>AGGR_INIT_EXPR</code> represents the initialization as the return
value of a function call, or as the result of a constructor.  An
<code>AGGR_INIT_EXPR</code> will only appear as a full-expression, or as the
second operand of a <code>TARGET_EXPR</code>.  <code>AGGR_INIT_EXPR</code>s have
a representation similar to that of <code>CALL_EXPR</code>s.  You can use
the <code>AGGR_INIT_EXPR_FN</code> and <code>AGGR_INIT_EXPR_ARG</code> macros to access
the function to call and the arguments to pass.

     <p>If <code>AGGR_INIT_VIA_CTOR_P</code> holds of the <code>AGGR_INIT_EXPR</code>, then
the initialization is via a constructor call.  The address of the
<code>AGGR_INIT_EXPR_SLOT</code> operand, which is always a <code>VAR_DECL</code>,
is taken, and this value replaces the first argument in the argument
list.

     <p>In either case, the expression is void.

     <br><dt><code>VA_ARG_EXPR</code><dd>This node is used to implement support for the C/C++ variable argument-list
mechanism.  It represents expressions like <code>va_arg (ap, type)</code>. 
Its <code>TREE_TYPE</code> yields the tree representation for <code>type</code> and
its sole argument yields the representation for <code>ap</code>.

     <br><dt><code>CHANGE_DYNAMIC_TYPE_EXPR</code><dd>Indicates the special aliasing required by C++ placement new.  It has
two operands: a type and a location.  It means that the dynamic type
of the location is changing to be the specified type.  The alias
analysis code takes this into account when doing type based alias
analysis.

     <br><dt><code>OMP_PARALLEL</code><dd>
Represents <code>#pragma omp parallel [clause1 ... clauseN]</code>. It
has four operands:

     <p>Operand <code>OMP_PARALLEL_BODY</code> is valid while in GENERIC and
High GIMPLE forms.  It contains the body of code to be executed
by all the threads.  During GIMPLE lowering, this operand becomes
<code>NULL</code> and the body is emitted linearly after
<code>OMP_PARALLEL</code>.

     <p>Operand <code>OMP_PARALLEL_CLAUSES</code> is the list of clauses
associated with the directive.

     <p>Operand <code>OMP_PARALLEL_FN</code> is created by
<code>pass_lower_omp</code>, it contains the <code>FUNCTION_DECL</code>
for the function that will contain the body of the parallel
region.

     <p>Operand <code>OMP_PARALLEL_DATA_ARG</code> is also created by
<code>pass_lower_omp</code>. If there are shared variables to be
communicated to the children threads, this operand will contain
the <code>VAR_DECL</code> that contains all the shared values and
variables.

     <br><dt><code>OMP_FOR</code><dd>
Represents <code>#pragma omp for [clause1 ... clauseN]</code>.  It
has 5 operands:

     <p>Operand <code>OMP_FOR_BODY</code> contains the loop body.

     <p>Operand <code>OMP_FOR_CLAUSES</code> is the list of clauses
associated with the directive.

     <p>Operand <code>OMP_FOR_INIT</code> is the loop initialization code of
the form <code>VAR = N1</code>.

     <p>Operand <code>OMP_FOR_COND</code> is the loop conditional expression
of the form <code>VAR {&lt;,&gt;,&lt;=,&gt;=} N2</code>.

     <p>Operand <code>OMP_FOR_INCR</code> is the loop index increment of the
form <code>VAR {+=,-=} INCR</code>.

     <p>Operand <code>OMP_FOR_PRE_BODY</code> contains side-effect code from
operands <code>OMP_FOR_INIT</code>, <code>OMP_FOR_COND</code> and
<code>OMP_FOR_INC</code>.  These side-effects are part of the
<code>OMP_FOR</code> block but must be evaluated before the start of
loop body.

     <p>The loop index variable <code>VAR</code> must be a signed integer variable,
which is implicitly private to each thread.  Bounds
<code>N1</code> and <code>N2</code> and the increment expression
<code>INCR</code> are required to be loop invariant integer
expressions that are evaluated without any synchronization. The
evaluation order, frequency of evaluation and side-effects are
unspecified by the standard.

     <br><dt><code>OMP_SECTIONS</code><dd>
Represents <code>#pragma omp sections [clause1 ... clauseN]</code>.

     <p>Operand <code>OMP_SECTIONS_BODY</code> contains the sections body,
which in turn contains a set of <code>OMP_SECTION</code> nodes for
each of the concurrent sections delimited by <code>#pragma omp
section</code>.

     <p>Operand <code>OMP_SECTIONS_CLAUSES</code> is the list of clauses
associated with the directive.

     <br><dt><code>OMP_SECTION</code><dd>
Section delimiter for <code>OMP_SECTIONS</code>.

     <br><dt><code>OMP_SINGLE</code><dd>
Represents <code>#pragma omp single</code>.

     <p>Operand <code>OMP_SINGLE_BODY</code> contains the body of code to be
executed by a single thread.

     <p>Operand <code>OMP_SINGLE_CLAUSES</code> is the list of clauses
associated with the directive.

     <br><dt><code>OMP_MASTER</code><dd>
Represents <code>#pragma omp master</code>.

     <p>Operand <code>OMP_MASTER_BODY</code> contains the body of code to be
executed by the master thread.

     <br><dt><code>OMP_ORDERED</code><dd>
Represents <code>#pragma omp ordered</code>.

     <p>Operand <code>OMP_ORDERED_BODY</code> contains the body of code to be
executed in the sequential order dictated by the loop index
variable.

     <br><dt><code>OMP_CRITICAL</code><dd>
Represents <code>#pragma omp critical [name]</code>.

     <p>Operand <code>OMP_CRITICAL_BODY</code> is the critical section.

     <p>Operand <code>OMP_CRITICAL_NAME</code> is an optional identifier to
label the critical section.

     <br><dt><code>OMP_RETURN</code><dd>
This does not represent any OpenMP directive, it is an artificial
marker to indicate the end of the body of an OpenMP. It is used
by the flow graph (<code>tree-cfg.c</code>) and OpenMP region
building code (<code>omp-low.c</code>).

     <br><dt><code>OMP_CONTINUE</code><dd>
Similarly, this instruction does not represent an OpenMP
directive, it is used by <code>OMP_FOR</code> and
<code>OMP_SECTIONS</code> to mark the place where the code needs to
loop to the next iteration (in the case of <code>OMP_FOR</code>) or
the next section (in the case of <code>OMP_SECTIONS</code>).

     <p>In some cases, <code>OMP_CONTINUE</code> is placed right before
<code>OMP_RETURN</code>.  But if there are cleanups that need to
occur right after the looping body, it will be emitted between
<code>OMP_CONTINUE</code> and <code>OMP_RETURN</code>.

     <br><dt><code>OMP_ATOMIC</code><dd>
Represents <code>#pragma omp atomic</code>.

     <p>Operand 0 is the address at which the atomic operation is to be
performed.

     <p>Operand 1 is the expression to evaluate.  The gimplifier tries
three alternative code generation strategies.  Whenever possible,
an atomic update built-in is used.  If that fails, a
compare-and-swap loop is attempted.  If that also fails, a
regular critical section around the expression is used.

     <br><dt><code>OMP_CLAUSE</code><dd>
Represents clauses associated with one of the <code>OMP_</code> directives. 
Clauses are represented by separate sub-codes defined in
<samp><span class="file">tree.h</span></samp>.  Clauses codes can be one of:
<code>OMP_CLAUSE_PRIVATE</code>, <code>OMP_CLAUSE_SHARED</code>,
<code>OMP_CLAUSE_FIRSTPRIVATE</code>,
<code>OMP_CLAUSE_LASTPRIVATE</code>, <code>OMP_CLAUSE_COPYIN</code>,
<code>OMP_CLAUSE_COPYPRIVATE</code>, <code>OMP_CLAUSE_IF</code>,
<code>OMP_CLAUSE_NUM_THREADS</code>, <code>OMP_CLAUSE_SCHEDULE</code>,
<code>OMP_CLAUSE_NOWAIT</code>, <code>OMP_CLAUSE_ORDERED</code>,
<code>OMP_CLAUSE_DEFAULT</code>, and <code>OMP_CLAUSE_REDUCTION</code>.  Each code
represents the corresponding OpenMP clause.

     <p>Clauses associated with the same directive are chained together
via <code>OMP_CLAUSE_CHAIN</code>. Those clauses that accept a list
of variables are restricted to exactly one, accessed with
<code>OMP_CLAUSE_VAR</code>.  Therefore, multiple variables under the
same clause <code>C</code> need to be represented as multiple <code>C</code> clauses
chained together.  This facilitates adding new clauses during
compilation.

     <br><dt><code>VEC_LSHIFT_EXPR</code><br><dt><code>VEC_RSHIFT_EXPR</code><dd>These nodes represent whole vector left and right shifts, respectively. 
The first operand is the vector to shift; it will always be of vector type. 
The second operand is an expression for the number of bits by which to
shift.  Note that the result is undefined if the second operand is larger
than or equal to the first operand's type size.

     <br><dt><code>VEC_WIDEN_MULT_HI_EXPR</code><br><dt><code>VEC_WIDEN_MULT_LO_EXPR</code><dd>These nodes represent widening vector multiplication of the high and low
parts of the two input vectors, respectively.  Their operands are vectors
that contain the same number of elements (<code>N</code>) of the same integral type. 
The result is a vector that contains half as many elements, of an integral type
whose size is twice as wide.  In the case of <code>VEC_WIDEN_MULT_HI_EXPR</code> the
high <code>N/2</code> elements of the two vector are multiplied to produce the
vector of <code>N/2</code> products. In the case of <code>VEC_WIDEN_MULT_LO_EXPR</code> the
low <code>N/2</code> elements of the two vector are multiplied to produce the
vector of <code>N/2</code> products.

     <br><dt><code>VEC_UNPACK_HI_EXPR</code><br><dt><code>VEC_UNPACK_LO_EXPR</code><dd>These nodes represent unpacking of the high and low parts of the input vector,
respectively.  The single operand is a vector that contains <code>N</code> elements
of the same integral or floating point type.  The result is a vector
that contains half as many elements, of an integral or floating point type
whose size is twice as wide.  In the case of <code>VEC_UNPACK_HI_EXPR</code> the
high <code>N/2</code> elements of the vector are extracted and widened (promoted). 
In the case of <code>VEC_UNPACK_LO_EXPR</code> the low <code>N/2</code> elements of the
vector are extracted and widened (promoted).

     <br><dt><code>VEC_UNPACK_FLOAT_HI_EXPR</code><br><dt><code>VEC_UNPACK_FLOAT_LO_EXPR</code><dd>These nodes represent unpacking of the high and low parts of the input vector,
where the values are converted from fixed point to floating point.  The
single operand is a vector that contains <code>N</code> elements of the same
integral type.  The result is a vector that contains half as many elements
of a floating point type whose size is twice as wide.  In the case of
<code>VEC_UNPACK_HI_EXPR</code> the high <code>N/2</code> elements of the vector are
extracted, converted and widened.  In the case of <code>VEC_UNPACK_LO_EXPR</code>
the low <code>N/2</code> elements of the vector are extracted, converted and widened.

     <br><dt><code>VEC_PACK_TRUNC_EXPR</code><dd>This node represents packing of truncated elements of the two input vectors
into the output vector.  Input operands are vectors that contain the same
number of elements of the same integral or floating point type.  The result
is a vector that contains twice as many elements of an integral or floating
point type whose size is half as wide. The elements of the two vectors are
demoted and merged (concatenated) to form the output vector.

     <br><dt><code>VEC_PACK_SAT_EXPR</code><dd>This node represents packing of elements of the two input vectors into the
output vector using saturation.  Input operands are vectors that contain
the same number of elements of the same integral type.  The result is a
vector that contains twice as many elements of an integral type whose size
is half as wide.  The elements of the two vectors are demoted and merged
(concatenated) to form the output vector.

     <br><dt><code>VEC_PACK_FIX_TRUNC_EXPR</code><dd>This node represents packing of elements of the two input vectors into the
output vector, where the values are converted from floating point
to fixed point.  Input operands are vectors that contain the same number
of elements of a floating point type.  The result is a vector that contains
twice as many elements of an integral type whose size is half as wide.  The
elements of the two vectors are merged (concatenated) to form the output
vector.

     <br><dt><code>VEC_EXTRACT_EVEN_EXPR</code><br><dt><code>VEC_EXTRACT_ODD_EXPR</code><dd>These nodes represent extracting of the even/odd elements of the two input
vectors, respectively. Their operands and result are vectors that contain the
same number of elements of the same type.

     <br><dt><code>VEC_INTERLEAVE_HIGH_EXPR</code><br><dt><code>VEC_INTERLEAVE_LOW_EXPR</code><dd>These nodes represent merging and interleaving of the high/low elements of the
two input vectors, respectively. The operands and the result are vectors that
contain the same number of elements (<code>N</code>) of the same type. 
In the case of <code>VEC_INTERLEAVE_HIGH_EXPR</code>, the high <code>N/2</code> elements of
the first input vector are interleaved with the high <code>N/2</code> elements of the
second input vector. In the case of <code>VEC_INTERLEAVE_LOW_EXPR</code>, the low
<code>N/2</code> elements of the first input vector are interleaved with the low
<code>N/2</code> elements of the second input vector.

 </dl>

<!-- Copyright (c) 2004, 2005, 2007, 2008 Free Software Foundation, Inc. -->
<!-- Free Software Foundation, Inc. -->
<!-- This is part of the GCC manual. -->
<!-- For copying conditions, see the file gcc.texi. -->
<!--  -->
<!-- Tree SSA -->
<!--  -->
 </body></html>

