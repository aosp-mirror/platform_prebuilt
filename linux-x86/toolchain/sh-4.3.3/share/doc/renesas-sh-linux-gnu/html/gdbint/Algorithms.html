<html lang="en">
<head>
<title>Algorithms - GDB Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GDB Internals">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Overall-Structure.html#Overall-Structure" title="Overall Structure">
<link rel="next" href="User-Interface.html#User-Interface" title="User Interface">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="../cs.css">
</head>
<body>
<div class="node">
<a name="Algorithms"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="User-Interface.html#User-Interface">User Interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Overall-Structure.html#Overall-Structure">Overall Structure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">3 Algorithms</h2>

<p><a name="index-algorithms-5"></a>
<span class="sc">gdb</span> uses a number of debugging-specific algorithms.  They are
often not very complicated, but get lost in the thicket of special
cases and real-world issues.  This chapter describes the basic
algorithms and mentions some of the specific target definitions that
they use.

<h3 class="section">3.1 Prologue Analysis</h3>

<p><a name="index-prologue-analysis-6"></a><a name="index-call-frame-information-7"></a><a name="index-CFI-_0028call-frame-information_0029-8"></a>To produce a backtrace and allow the user to manipulate older frames'
variables and arguments, <span class="sc">gdb</span> needs to find the base addresses
of older frames, and discover where those frames' registers have been
saved.  Since a frame's &ldquo;callee-saves&rdquo; registers get saved by
younger frames if and when they're reused, a frame's registers may be
scattered unpredictably across younger frames.  This means that
changing the value of a register-allocated variable in an older frame
may actually entail writing to a save slot in some younger frame.

   <p>Modern versions of GCC emit Dwarf call frame information (&ldquo;CFI&rdquo;),
which describes how to find frame base addresses and saved registers. 
But CFI is not always available, so as a fallback <span class="sc">gdb</span> uses a
technique called <dfn>prologue analysis</dfn> to find frame sizes and saved
registers.  A prologue analyzer disassembles the function's machine
code starting from its entry point, and looks for instructions that
allocate frame space, save the stack pointer in a frame pointer
register, save registers, and so on.  Obviously, this can't be done
accurately in general, but it's tractable to do well enough to be very
helpful.  Prologue analysis predates the GNU toolchain's support for
CFI; at one time, prologue analysis was the only mechanism
<span class="sc">gdb</span> used for stack unwinding at all, when the function
calling conventions didn't specify a fixed frame layout.

   <p>In the olden days, function prologues were generated by hand-written,
target-specific code in GCC, and treated as opaque and untouchable by
optimizers.  Looking at this code, it was usually straightforward to
write a prologue analyzer for <span class="sc">gdb</span> that would accurately
understand all the prologues GCC would generate.  However, over time
GCC became more aggressive about instruction scheduling, and began to
understand more about the semantics of the prologue instructions
themselves; in response, <span class="sc">gdb</span>'s analyzers became more complex
and fragile.  Keeping the prologue analyzers working as GCC (and the
instruction sets themselves) evolved became a substantial task.

   <p><a name="index-g_t_0040file_007bprologue_002dvalue_002ec_007d-9"></a><a name="index-abstract-interpretation-of-function-prologues-10"></a><a name="index-pseudo_002devaluation-of-function-prologues-11"></a>To try to address this problem, the code in <samp><span class="file">prologue-value.h</span></samp>
and <samp><span class="file">prologue-value.c</span></samp> provides a general framework for writing
prologue analyzers that are simpler and more robust than ad-hoc
analyzers.  When we analyze a prologue using the prologue-value
framework, we're really doing &ldquo;abstract interpretation&rdquo; or
&ldquo;pseudo-evaluation&rdquo;: running the function's code in simulation, but
using conservative approximations of the values registers and memory
would hold when the code actually runs.  For example, if our function
starts with the instruction:

<pre class="example">     addi r1, 42     # add 42 to r1
</pre>
   <p class="noindent">we don't know exactly what value will be in <code>r1</code> after executing
this instruction, but we do know it'll be 42 greater than its original
value.

   <p>If we then see an instruction like:

<pre class="example">     addi r1, 22     # add 22 to r1
</pre>
   <p class="noindent">we still don't know what <code>r1's</code> value is, but again, we can say
it is now 64 greater than its original value.

   <p>If the next instruction were:

<pre class="example">     mov r2, r1      # set r2 to r1's value
</pre>
   <p class="noindent">then we can say that <code>r2's</code> value is now the original value of
<code>r1</code> plus 64.

   <p>It's common for prologues to save registers on the stack, so we'll
need to track the values of stack frame slots, as well as the
registers.  So after an instruction like this:

<pre class="example">     mov (fp+4), r2
</pre>
   <p class="noindent">then we'd know that the stack slot four bytes above the frame pointer
holds the original value of <code>r1</code> plus 64.

   <p>And so on.

   <p>Of course, this can only go so far before it gets unreasonable.  If we
wanted to be able to say anything about the value of <code>r1</code> after
the instruction:

<pre class="example">     xor r1, r3      # exclusive-or r1 and r3, place result in r1
</pre>
   <p class="noindent">then things would get pretty complex.  But remember, we're just doing
a conservative approximation; if exclusive-or instructions aren't
relevant to prologues, we can just say <code>r1</code>'s value is now
&ldquo;unknown&rdquo;.  We can ignore things that are too complex, if that loss of
information is acceptable for our application.

   <p>So when we say &ldquo;conservative approximation&rdquo; here, what we mean is an
approximation that is either accurate, or marked &ldquo;unknown&rdquo;, but
never inaccurate.

   <p>Using this framework, a prologue analyzer is simply an interpreter for
machine code, but one that uses conservative approximations for the
contents of registers and memory instead of actual values.  Starting
from the function's entry point, you simulate instructions up to the
current PC, or an instruction that you don't know how to simulate. 
Now you can examine the state of the registers and stack slots you've
kept track of.

     <ul>
<li>To see how large your stack frame is, just check the value of the
stack pointer register; if it's the original value of the SP
minus a constant, then that constant is the stack frame's size. 
If the SP's value has been marked as &ldquo;unknown&rdquo;, then that means
the prologue has done something too complex for us to track, and
we don't know the frame size.

     <li>To see where we've saved the previous frame's registers, we just
search the values we've tracked &mdash; stack slots, usually, but
registers, too, if you want &mdash; for something equal to the register's
original value.  If the calling conventions suggest a standard place
to save a given register, then we can check there first, but really,
anything that will get us back the original value will probably work. 
</ul>

   <p>This does take some work.  But prologue analyzers aren't
quick-and-simple pattern patching to recognize a few fixed prologue
forms any more; they're big, hairy functions.  Along with inferior
function calls, prologue analysis accounts for a substantial portion
of the time needed to stabilize a <span class="sc">gdb</span> port.  So it's
worthwhile to look for an approach that will be easier to understand
and maintain.  In the approach described above:

     <ul>
<li>It's easier to see that the analyzer is correct: you just see
whether the analyzer properly (albeit conservatively) simulates
the effect of each instruction.

     <li>It's easier to extend the analyzer: you can add support for new
instructions, and know that you haven't broken anything that
wasn't already broken before.

     <li>It's orthogonal: to gather new information, you don't need to
complicate the code for each instruction.  As long as your domain
of conservative values is already detailed enough to tell you
what you need, then all the existing instruction simulations are
already gathering the right data for you.

   </ul>

   <p>The file <samp><span class="file">prologue-value.h</span></samp> contains detailed comments explaining
the framework and how to use it.

<h3 class="section">3.2 Breakpoint Handling</h3>

<p><a name="index-breakpoints-12"></a>In general, a breakpoint is a user-designated location in the program
where the user wants to regain control if program execution ever reaches
that location.

   <p>There are two main ways to implement breakpoints; either as &ldquo;hardware&rdquo;
breakpoints or as &ldquo;software&rdquo; breakpoints.

   <p><a name="index-hardware-breakpoints-13"></a><a name="index-program-counter-14"></a>Hardware breakpoints are sometimes available as a builtin debugging
features with some chips.  Typically these work by having dedicated
register into which the breakpoint address may be stored.  If the PC
(shorthand for <dfn>program counter</dfn>)
ever matches a value in a breakpoint registers, the CPU raises an
exception and reports it to <span class="sc">gdb</span>.

   <p>Another possibility is when an emulator is in use; many emulators
include circuitry that watches the address lines coming out from the
processor, and force it to stop if the address matches a breakpoint's
address.

   <p>A third possibility is that the target already has the ability to do
breakpoints somehow; for instance, a ROM monitor may do its own
software breakpoints.  So although these are not literally &ldquo;hardware
breakpoints&rdquo;, from <span class="sc">gdb</span>'s point of view they work the same;
<span class="sc">gdb</span> need not do anything more than set the breakpoint and wait
for something to happen.

   <p>Since they depend on hardware resources, hardware breakpoints may be
limited in number; when the user asks for more, <span class="sc">gdb</span> will
start trying to set software breakpoints.  (On some architectures,
notably the 32-bit x86 platforms, <span class="sc">gdb</span> cannot always know
whether there's enough hardware resources to insert all the hardware
breakpoints and watchpoints.  On those platforms, <span class="sc">gdb</span> prints
an error message only when the program being debugged is continued.)

   <p><a name="index-software-breakpoints-15"></a>Software breakpoints require <span class="sc">gdb</span> to do somewhat more work. 
The basic theory is that <span class="sc">gdb</span> will replace a program
instruction with a trap, illegal divide, or some other instruction
that will cause an exception, and then when it's encountered,
<span class="sc">gdb</span> will take the exception and stop the program.  When the
user says to continue, <span class="sc">gdb</span> will restore the original
instruction, single-step, re-insert the trap, and continue on.

   <p>Since it literally overwrites the program being tested, the program area
must be writable, so this technique won't work on programs in ROM.  It
can also distort the behavior of programs that examine themselves,
although such a situation would be highly unusual.

   <p>Also, the software breakpoint instruction should be the smallest size of
instruction, so it doesn't overwrite an instruction that might be a jump
target, and cause disaster when the program jumps into the middle of the
breakpoint instruction.  (Strictly speaking, the breakpoint must be no
larger than the smallest interval between instructions that may be jump
targets; perhaps there is an architecture where only even-numbered
instructions may jumped to.)  Note that it's possible for an instruction
set not to have any instructions usable for a software breakpoint,
although in practice only the ARC has failed to define such an
instruction.

   <p>Basic breakpoint object handling is in <samp><span class="file">breakpoint.c</span></samp>.  However,
much of the interesting breakpoint action is in <samp><span class="file">infrun.c</span></samp>.

     
<a name="index-insert-or-remove-software-breakpoint-16"></a>
<a name="index-target_005fremove_005fbreakpoint-17"></a>
<a name="index-target_005finsert_005fbreakpoint-18"></a>
<dl><dt><code>target_remove_breakpoint (</code><var>bp_tgt</var><code>)</code><dt><code>target_insert_breakpoint (</code><var>bp_tgt</var><code>)</code><dd>Insert or remove a software breakpoint at address
<var>bp_tgt</var><code>-&gt;placed_address</code>.  Returns zero for success,
non-zero for failure.  On input, <var>bp_tgt</var> contains the address of the
breakpoint, and is otherwise initialized to zero.  The fields of the
<code>struct bp_target_info</code> pointed to by <var>bp_tgt</var> are updated
to contain other information about the breakpoint on output.  The field
<code>placed_address</code> may be updated if the breakpoint was placed at a
related address; the field <code>shadow_contents</code> contains the real
contents of the bytes where the breakpoint has been inserted,
if reading memory would return the breakpoint instead of the
underlying memory; the field <code>shadow_len</code> is the length of
memory cached in <code>shadow_contents</code>, if any; and the field
<code>placed_size</code> is optionally set and used by the target, if
it could differ from <code>shadow_len</code>.

     <p>For example, the remote target &lsquo;<samp><span class="samp">Z0</span></samp>&rsquo; packet does not require
shadowing memory, so <code>shadow_len</code> is left at zero.  However,
the length reported by <code>gdbarch_breakpoint_from_pc</code> is cached in
<code>placed_size</code>, so that a matching &lsquo;<samp><span class="samp">z0</span></samp>&rsquo; packet can be
used to remove the breakpoint.

     <p><a name="index-insert-or-remove-hardware-breakpoint-19"></a><a name="index-target_005fremove_005fhw_005fbreakpoint-20"></a><a name="index-target_005finsert_005fhw_005fbreakpoint-21"></a><br><dt><code>target_remove_hw_breakpoint (</code><var>bp_tgt</var><code>)</code><dt><code>target_insert_hw_breakpoint (</code><var>bp_tgt</var><code>)</code><dd>Insert or remove a hardware-assisted breakpoint at address
<var>bp_tgt</var><code>-&gt;placed_address</code>.  Returns zero for success,
non-zero for failure.  See <code>target_insert_breakpoint</code> for
a description of the <code>struct bp_target_info</code> pointed to by
<var>bp_tgt</var>; the <code>shadow_contents</code> and
<code>shadow_len</code> members are not used for hardware breakpoints,
but <code>placed_size</code> may be. 
</dl>

<h3 class="section">3.3 Single Stepping</h3>

<h3 class="section">3.4 Signal Handling</h3>

<h3 class="section">3.5 Thread Handling</h3>

<h3 class="section">3.6 Inferior Function Calls</h3>

<h3 class="section">3.7 Longjmp Support</h3>

<p><a name="index-g_t_0040code_007blongjmp_007d-debugging-22"></a><span class="sc">gdb</span> has support for figuring out that the target is doing a
<code>longjmp</code> and for stopping at the target of the jump, if we are
stepping.  This is done with a few specialized internal breakpoints,
which are visible in the output of the &lsquo;<samp><span class="samp">maint info breakpoint</span></samp>&rsquo;
command.

   <p><a name="index-gdbarch_005fget_005flongjmp_005ftarget-23"></a>To make this work, you need to define a function called
<code>gdbarch_get_longjmp_target</code>, which will examine the
<code>jmp_buf</code> structure and extract the <code>longjmp</code> target address. 
Since <code>jmp_buf</code> is target specific and typically defined in a
target header not available to <span class="sc">gdb</span>, you will need to
determine the offset of the PC manually and return that; many targets
define a <code>jb_pc_offset</code> field in the tdep structure to save the
value once calculated.

<h3 class="section">3.8 Watchpoints</h3>

<p><a name="index-watchpoints-24"></a>
Watchpoints are a special kind of breakpoints (see <a href="Algorithms.html#Algorithms">breakpoints</a>) which break when data is accessed rather than when some
instruction is executed.  When you have data which changes without
your knowing what code does that, watchpoints are the silver bullet to
hunt down and kill such bugs.

   <p><a name="index-hardware-watchpoints-25"></a><a name="index-software-watchpoints-26"></a>Watchpoints can be either hardware-assisted or not; the latter type is
known as &ldquo;software watchpoints.&rdquo;  <span class="sc">gdb</span> always uses
hardware-assisted watchpoints if they are available, and falls back on
software watchpoints otherwise.  Typical situations where <span class="sc">gdb</span>
will use software watchpoints are:

     <ul>
<li>The watched memory region is too large for the underlying hardware
watchpoint support.  For example, each x86 debug register can watch up
to 4 bytes of memory, so trying to watch data structures whose size is
more than 16 bytes will cause <span class="sc">gdb</span> to use software
watchpoints.

     <li>The value of the expression to be watched depends on data held in
registers (as opposed to memory).

     <li>Too many different watchpoints requested.  (On some architectures,
this situation is impossible to detect until the debugged program is
resumed.)  Note that x86 debug registers are used both for hardware
breakpoints and for watchpoints, so setting too many hardware
breakpoints might cause watchpoint insertion to fail.

     <li>No hardware-assisted watchpoints provided by the target
implementation. 
</ul>

   <p>Software watchpoints are very slow, since <span class="sc">gdb</span> needs to
single-step the program being debugged and test the value of the
watched expression(s) after each instruction.  The rest of this
section is mostly irrelevant for software watchpoints.

   <p>When the inferior stops, <span class="sc">gdb</span> tries to establish, among other
possible reasons, whether it stopped due to a watchpoint being hit. 
It first uses <code>STOPPED_BY_WATCHPOINT</code> to see if any watchpoint
was hit.  If not, all watchpoint checking is skipped.

   <p>Then <span class="sc">gdb</span> calls <code>target_stopped_data_address</code> exactly
once.  This method returns the address of the watchpoint which
triggered, if the target can determine it.  If the triggered address
is available, <span class="sc">gdb</span> compares the address returned by this
method with each watched memory address in each active watchpoint. 
For data-read and data-access watchpoints, <span class="sc">gdb</span> announces
every watchpoint that watches the triggered address as being hit. 
For this reason, data-read and data-access watchpoints
<em>require</em> that the triggered address be available; if not, read
and access watchpoints will never be considered hit.  For data-write
watchpoints, if the triggered address is available, <span class="sc">gdb</span>
considers only those watchpoints which match that address;
otherwise, <span class="sc">gdb</span> considers all data-write watchpoints.  For
each data-write watchpoint that <span class="sc">gdb</span> considers, it evaluates
the expression whose value is being watched, and tests whether the
watched value has changed.  Watchpoints whose watched values have
changed are announced as hit.

<!-- FIXME move these to the main lists of target/native defns -->
   <p><span class="sc">gdb</span> uses several macros and primitives to support hardware
watchpoints:

     
<a name="index-TARGET_005fHAS_005fHARDWARE_005fWATCHPOINTS-27"></a>
<dl><dt><code>TARGET_HAS_HARDWARE_WATCHPOINTS</code><dd>If defined, the target supports hardware watchpoints. 
(Currently only used for several native configs.)

     <p><a name="index-TARGET_005fCAN_005fUSE_005fHARDWARE_005fWATCHPOINT-28"></a><br><dt><code>TARGET_CAN_USE_HARDWARE_WATCHPOINT (</code><var>type</var><code>, </code><var>count</var><code>, </code><var>other</var><code>)</code><dd>Return the number of hardware watchpoints of type <var>type</var> that are
possible to be set.  The value is positive if <var>count</var> watchpoints
of this type can be set, zero if setting watchpoints of this type is
not supported, and negative if <var>count</var> is more than the maximum
number of watchpoints of type <var>type</var> that can be set.  <var>other</var>
is non-zero if other types of watchpoints are currently enabled (there
are architectures which cannot set watchpoints of different types at
the same time).

     <p><a name="index-TARGET_005fREGION_005fOK_005fFOR_005fHW_005fWATCHPOINT-29"></a><br><dt><code>TARGET_REGION_OK_FOR_HW_WATCHPOINT (</code><var>addr</var><code>, </code><var>len</var><code>)</code><dd>Return non-zero if hardware watchpoints can be used to watch a region
whose address is <var>addr</var> and whose length in bytes is <var>len</var>.

     <p><a name="index-insert-or-remove-hardware-watchpoint-30"></a><a name="index-target_005finsert_005fwatchpoint-31"></a><a name="index-target_005fremove_005fwatchpoint-32"></a><br><dt><code>target_insert_watchpoint (</code><var>addr</var><code>, </code><var>len</var><code>, </code><var>type</var><code>)</code><dt><code>target_remove_watchpoint (</code><var>addr</var><code>, </code><var>len</var><code>, </code><var>type</var><code>)</code><dd>Insert or remove a hardware watchpoint starting at <var>addr</var>, for
<var>len</var> bytes.  <var>type</var> is the watchpoint type, one of the
possible values of the enumerated data type <code>target_hw_bp_type</code>,
defined by <samp><span class="file">breakpoint.h</span></samp> as follows:

     <pre class="smallexample">           enum target_hw_bp_type
             {
               hw_write   = 0, /* Common (write) HW watchpoint */
               hw_read    = 1, /* Read    HW watchpoint */
               hw_access  = 2, /* Access (read or write) HW watchpoint */
               hw_execute = 3  /* Execute HW breakpoint */
             };
</pre>
     <p class="noindent">These two macros should return 0 for success, non-zero for failure.

     <p><a name="index-target_005fstopped_005fdata_005faddress-33"></a><br><dt><code>target_stopped_data_address (</code><var>addr_p</var><code>)</code><dd>If the inferior has some watchpoint that triggered, place the address
associated with the watchpoint at the location pointed to by
<var>addr_p</var> and return non-zero.  Otherwise, return zero.  This
is required for data-read and data-access watchpoints.  It is
not required for data-write watchpoints, but <span class="sc">gdb</span> uses
it to improve handling of those also.

     <p><span class="sc">gdb</span> will only call this method once per watchpoint stop,
immediately after calling <code>STOPPED_BY_WATCHPOINT</code>.  If the
target's watchpoint indication is sticky, i.e., stays set after
resuming, this method should clear it.  For instance, the x86 debug
control register has sticky triggered flags.

     <p><a name="index-target_005fwatchpoint_005faddr_005fwithin_005frange-34"></a><br><dt><code>target_watchpoint_addr_within_range (</code><var>target</var><code>, </code><var>addr</var><code>, </code><var>start</var><code>, </code><var>length</var><code>)</code><dd>Check whether <var>addr</var> (as returned by <code>target_stopped_data_address</code>)
lies within the hardware-defined watchpoint region described by
<var>start</var> and <var>length</var>.  This only needs to be provided if the
granularity of a watchpoint is greater than one byte, i.e., if the
watchpoint can also trigger on nearby addresses outside of the watched
region.

     <p><a name="index-HAVE_005fSTEPPABLE_005fWATCHPOINT-35"></a><br><dt><code>HAVE_STEPPABLE_WATCHPOINT</code><dd>If defined to a non-zero value, it is not necessary to disable a
watchpoint to step over it.  Like <code>gdbarch_have_nonsteppable_watchpoint</code>,
this is usually set when watchpoints trigger at the instruction
which will perform an interesting read or write.  It should be
set if there is a temporary disable bit which allows the processor
to step over the interesting instruction without raising the
watchpoint exception again.

     <p><a name="index-gdbarch_005fhave_005fnonsteppable_005fwatchpoint-36"></a><br><dt><code>int gdbarch_have_nonsteppable_watchpoint (</code><var>gdbarch</var><code>)</code><dd>If it returns a non-zero value, <span class="sc">gdb</span> should disable a
watchpoint to step the inferior over it.  This is usually set when
watchpoints trigger at the instruction which will perform an
interesting read or write.

     <p><a name="index-HAVE_005fCONTINUABLE_005fWATCHPOINT-37"></a><br><dt><code>HAVE_CONTINUABLE_WATCHPOINT</code><dd>If defined to a non-zero value, it is possible to continue the
inferior after a watchpoint has been hit.  This is usually set
when watchpoints trigger at the instruction following an interesting
read or write.

     <p><a name="index-CANNOT_005fSTEP_005fHW_005fWATCHPOINTS-38"></a><br><dt><code>CANNOT_STEP_HW_WATCHPOINTS</code><dd>If this is defined to a non-zero value, <span class="sc">gdb</span> will remove all
watchpoints before stepping the inferior.

     <p><a name="index-STOPPED_005fBY_005fWATCHPOINT-39"></a><br><dt><code>STOPPED_BY_WATCHPOINT (</code><var>wait_status</var><code>)</code><dd>Return non-zero if stopped by a watchpoint.  <var>wait_status</var> is of
the type <code>struct target_waitstatus</code>, defined by <samp><span class="file">target.h</span></samp>. 
Normally, this macro is defined to invoke the function pointed to by
the <code>to_stopped_by_watchpoint</code> member of the structure (of the
type <code>target_ops</code>, defined on <samp><span class="file">target.h</span></samp>) that describes the
target-specific operations; <code>to_stopped_by_watchpoint</code> ignores
the <var>wait_status</var> argument.

     <p><span class="sc">gdb</span> does not require the non-zero value returned by
<code>STOPPED_BY_WATCHPOINT</code> to be 100% correct, so if a target cannot
determine for sure whether the inferior stopped due to a watchpoint,
it could return non-zero &ldquo;just in case&rdquo;. 
</dl>

<h4 class="subsection">3.8.1 Watchpoints and Threads</h4>

<p><a name="index-watchpoints_002c-with-threads-40"></a>
<span class="sc">gdb</span> only supports process-wide watchpoints, which trigger
in all threads.  <span class="sc">gdb</span> uses the thread ID to make watchpoints
act as if they were thread-specific, but it cannot set hardware
watchpoints that only trigger in a specific thread.  Therefore, even
if the target supports threads, per-thread debug registers, and
watchpoints which only affect a single thread, it should set the
per-thread debug registers for all threads to the same value.  On
<span class="sc">gnu</span>/Linux native targets, this is accomplished by using
<code>ALL_LWPS</code> in <code>target_insert_watchpoint</code> and
<code>target_remove_watchpoint</code> and by using
<code>linux_set_new_thread</code> to register a handler for newly created
threads.

   <p><span class="sc">gdb</span>'s <span class="sc">gnu</span>/Linux support only reports a single event
at a time, although multiple events can trigger simultaneously for
multi-threaded programs.  When multiple events occur, <samp><span class="file">linux-nat.c</span></samp>
queues subsequent events and returns them the next time the program
is resumed.  This means that <code>STOPPED_BY_WATCHPOINT</code> and
<code>target_stopped_data_address</code> only need to consult the current
thread's state&mdash;the thread indicated by <code>inferior_ptid</code>.  If
two threads have hit watchpoints simultaneously, those routines
will be called a second time for the second thread.

<h4 class="subsection">3.8.2 x86 Watchpoints</h4>

<p><a name="index-x86-debug-registers-41"></a><a name="index-watchpoints_002c-on-x86-42"></a>
The 32-bit Intel x86 (a.k.a. ia32) processors feature special debug
registers designed to facilitate debugging.  <span class="sc">gdb</span> provides a
generic library of functions that x86-based ports can use to implement
support for watchpoints and hardware-assisted breakpoints.  This
subsection documents the x86 watchpoint facilities in <span class="sc">gdb</span>.

   <p>(At present, the library functions read and write debug registers directly, and are
thus only available for native configurations.)

   <p>To use the generic x86 watchpoint support, a port should do the
following:

     
<a name="index-I386_005fUSE_005fGENERIC_005fWATCHPOINTS-43"></a>
<ul><li>Define the macro <code>I386_USE_GENERIC_WATCHPOINTS</code> somewhere in the
target-dependent headers.

     <li>Include the <samp><span class="file">config/i386/nm-i386.h</span></samp> header file <em>after</em>
defining <code>I386_USE_GENERIC_WATCHPOINTS</code>.

     <li>Add <samp><span class="file">i386-nat.o</span></samp> to the value of the Make variable
<code>NATDEPFILES</code> (see <a href="Native-Debugging.html#Native-Debugging">NATDEPFILES</a>) or
<code>TDEPFILES</code> (see <a href="Target-Architecture-Definition.html#Target-Architecture-Definition">TDEPFILES</a>).

     <li>Provide implementations for the <code>I386_DR_LOW_*</code> macros described
below.  Typically, each macro should call a target-specific function
which does the real work. 
</ul>

   <p>The x86 watchpoint support works by maintaining mirror images of the
debug registers.  Values are copied between the mirror images and the
real debug registers via a set of macros which each target needs to
provide:

     
<a name="index-I386_005fDR_005fLOW_005fSET_005fCONTROL-44"></a>
<dl><dt><code>I386_DR_LOW_SET_CONTROL (</code><var>val</var><code>)</code><dd>Set the Debug Control (DR7) register to the value <var>val</var>.

     <p><a name="index-I386_005fDR_005fLOW_005fSET_005fADDR-45"></a><br><dt><code>I386_DR_LOW_SET_ADDR (</code><var>idx</var><code>, </code><var>addr</var><code>)</code><dd>Put the address <var>addr</var> into the debug register number <var>idx</var>.

     <p><a name="index-I386_005fDR_005fLOW_005fRESET_005fADDR-46"></a><br><dt><code>I386_DR_LOW_RESET_ADDR (</code><var>idx</var><code>)</code><dd>Reset (i.e. zero out) the address stored in the debug register
number <var>idx</var>.

     <p><a name="index-I386_005fDR_005fLOW_005fGET_005fSTATUS-47"></a><br><dt><code>I386_DR_LOW_GET_STATUS</code><dd>Return the value of the Debug Status (DR6) register.  This value is
used immediately after it is returned by
<code>I386_DR_LOW_GET_STATUS</code>, so as to support per-thread status
register values. 
</dl>

   <p>For each one of the 4 debug registers (whose indices are from 0 to 3)
that store addresses, a reference count is maintained by <span class="sc">gdb</span>,
to allow sharing of debug registers by several watchpoints.  This
allows users to define several watchpoints that watch the same
expression, but with different conditions and/or commands, without
wasting debug registers which are in short supply.  <span class="sc">gdb</span>
maintains the reference counts internally, targets don't have to do
anything to use this feature.

   <p>The x86 debug registers can each watch a region that is 1, 2, or 4
bytes long.  The ia32 architecture requires that each watched region
be appropriately aligned: 2-byte region on 2-byte boundary, 4-byte
region on 4-byte boundary.  However, the x86 watchpoint support in
<span class="sc">gdb</span> can watch unaligned regions and regions larger than 4
bytes (up to 16 bytes) by allocating several debug registers to watch
a single region.  This allocation of several registers per a watched
region is also done automatically without target code intervention.

   <p>The generic x86 watchpoint support provides the following API for the
<span class="sc">gdb</span>'s application code:

     
<a name="index-i386_005fregion_005fok_005ffor_005fwatchpoint-48"></a>
<dl><dt><code>i386_region_ok_for_watchpoint (</code><var>addr</var><code>, </code><var>len</var><code>)</code><dd>The macro <code>TARGET_REGION_OK_FOR_HW_WATCHPOINT</code> is set to call
this function.  It counts the number of debug registers required to
watch a given region, and returns a non-zero value if that number is
less than 4, the number of debug registers available to x86
processors.

     <p><a name="index-i386_005fstopped_005fdata_005faddress-49"></a><br><dt><code>i386_stopped_data_address (</code><var>addr_p</var><code>)</code><dd>The target function
<code>target_stopped_data_address</code> is set to call this function. 
This
function examines the breakpoint condition bits in the DR6 Debug
Status register, as returned by the <code>I386_DR_LOW_GET_STATUS</code>
macro, and returns the address associated with the first bit that is
set in DR6.

     <p><a name="index-i386_005fstopped_005fby_005fwatchpoint-50"></a><br><dt><code>i386_stopped_by_watchpoint (void)</code><dd>The macro <code>STOPPED_BY_WATCHPOINT</code>
is set to call this function.  The
argument passed to <code>STOPPED_BY_WATCHPOINT</code> is ignored.  This
function examines the breakpoint condition bits in the DR6 Debug
Status register, as returned by the <code>I386_DR_LOW_GET_STATUS</code>
macro, and returns true if any bit is set.  Otherwise, false is
returned.

     <p><a name="index-i386_005finsert_005fwatchpoint-51"></a><a name="index-i386_005fremove_005fwatchpoint-52"></a><br><dt><code>i386_insert_watchpoint (</code><var>addr</var><code>, </code><var>len</var><code>, </code><var>type</var><code>)</code><dt><code>i386_remove_watchpoint (</code><var>addr</var><code>, </code><var>len</var><code>, </code><var>type</var><code>)</code><dd>Insert or remove a watchpoint.  The macros
<code>target_insert_watchpoint</code> and <code>target_remove_watchpoint</code>
are set to call these functions.  <code>i386_insert_watchpoint</code> first
looks for a debug register which is already set to watch the same
region for the same access types; if found, it just increments the
reference count of that debug register, thus implementing debug
register sharing between watchpoints.  If no such register is found,
the function looks for a vacant debug register, sets its mirrored
value to <var>addr</var>, sets the mirrored value of DR7 Debug Control
register as appropriate for the <var>len</var> and <var>type</var> parameters,
and then passes the new values of the debug register and DR7 to the
inferior by calling <code>I386_DR_LOW_SET_ADDR</code> and
<code>I386_DR_LOW_SET_CONTROL</code>.  If more than one debug register is
required to cover the given region, the above process is repeated for
each debug register.

     <p><code>i386_remove_watchpoint</code> does the opposite: it resets the address
in the mirrored value of the debug register and its read/write and
length bits in the mirrored value of DR7, then passes these new
values to the inferior via <code>I386_DR_LOW_RESET_ADDR</code> and
<code>I386_DR_LOW_SET_CONTROL</code>.  If a register is shared by several
watchpoints, each time a <code>i386_remove_watchpoint</code> is called, it
decrements the reference count, and only calls
<code>I386_DR_LOW_RESET_ADDR</code> and <code>I386_DR_LOW_SET_CONTROL</code> when
the count goes to zero.

     <p><a name="index-i386_005finsert_005fhw_005fbreakpoint-53"></a><a name="index-i386_005fremove_005fhw_005fbreakpoint-54"></a><br><dt><code>i386_insert_hw_breakpoint (</code><var>bp_tgt</var><code>)</code><dt><code>i386_remove_hw_breakpoint (</code><var>bp_tgt</var><code>)</code><dd>These functions insert and remove hardware-assisted breakpoints.  The
macros <code>target_insert_hw_breakpoint</code> and
<code>target_remove_hw_breakpoint</code> are set to call these functions. 
The argument is a <code>struct bp_target_info *</code>, as described in
the documentation for <code>target_insert_breakpoint</code>. 
These functions work like <code>i386_insert_watchpoint</code> and
<code>i386_remove_watchpoint</code>, respectively, except that they set up
the debug registers to watch instruction execution, and each
hardware-assisted breakpoint always requires exactly one debug
register.

     <p><a name="index-i386_005fstopped_005fby_005fhwbp-55"></a><br><dt><code>i386_stopped_by_hwbp (void)</code><dd>This function returns non-zero if the inferior has some watchpoint or
hardware breakpoint that triggered.  It works like
<code>i386_stopped_data_address</code>, except that it doesn't record the
address whose watchpoint triggered.

     <p><a name="index-i386_005fcleanup_005fdregs-56"></a><br><dt><code>i386_cleanup_dregs (void)</code><dd>This function clears all the reference counts, addresses, and control
bits in the mirror images of the debug registers.  It doesn't affect
the actual debug registers in the inferior process. 
</dl>

<p class="noindent"><strong>Notes:</strong>
     <ol type=1 start=1>
<li>x86 processors support setting watchpoints on I/O reads or writes. 
However, since no target supports this (as of March 2001), and since
<code>enum target_hw_bp_type</code> doesn't even have an enumeration for I/O
watchpoints, this feature is not yet available to <span class="sc">gdb</span> running
on x86.

     <li>x86 processors can enable watchpoints locally, for the current task
only, or globally, for all the tasks.  For each debug register,
there's a bit in the DR7 Debug Control register that determines
whether the associated address is watched locally or globally.  The
current implementation of x86 watchpoint support in <span class="sc">gdb</span>
always sets watchpoints to be locally enabled, since global
watchpoints might interfere with the underlying OS and are probably
unavailable in many platforms.
        </ol>

<h3 class="section">3.9 Checkpoints</h3>

<p><a name="index-checkpoints-57"></a><a name="index-restart-58"></a>In the abstract, a checkpoint is a point in the execution history of
the program, which the user may wish to return to at some later time.

   <p>Internally, a checkpoint is a saved copy of the program state, including
whatever information is required in order to restore the program to that
state at a later time.  This can be expected to include the state of
registers and memory, and may include external state such as the state
of open files and devices.

   <p>There are a number of ways in which checkpoints may be implemented
in gdb, e.g. as corefiles, as forked processes, and as some opaque
method implemented on the target side.

   <p>A corefile can be used to save an image of target memory and register
state, which can in principle be restored later &mdash; but corefiles do
not typically include information about external entities such as
open files.  Currently this method is not implemented in gdb.

   <p>A forked process can save the state of user memory and registers,
as well as some subset of external (kernel) state.  This method
is used to implement checkpoints on Linux, and in principle might
be used on other systems.

   <p>Some targets, e.g. simulators, might have their own built-in
method for saving checkpoints, and gdb might be able to take
advantage of that capability without necessarily knowing any
details of how it is done.

<h3 class="section">3.10 Observing changes in <span class="sc">gdb</span> internals</h3>

<p><a name="index-observer-pattern-interface-59"></a><a name="index-notifications-about-changes-in-internals-60"></a>
In order to function properly, several modules need to be notified when
some changes occur in the <span class="sc">gdb</span> internals.  Traditionally, these
modules have relied on several paradigms, the most common ones being
hooks and gdb-events.  Unfortunately, none of these paradigms was
versatile enough to become the standard notification mechanism in
<span class="sc">gdb</span>.  The fact that they only supported one &ldquo;client&rdquo; was also
a strong limitation.

   <p>A new paradigm, based on the Observer pattern of the <cite>Design
Patterns</cite> book, has therefore been implemented.  The goal was to provide
a new interface overcoming the issues with the notification mechanisms
previously available.  This new interface needed to be strongly typed,
easy to extend, and versatile enough to be used as the standard
interface when adding new notifications.

   <p>See <a href="GDB-Observers.html#GDB-Observers">GDB Observers</a> for a brief description of the observers
currently implemented in GDB. The rationale for the current
implementation is also briefly discussed.

   </body></html>

